// Import the browser client and rename it for convenience
import { supabaseBrowserClient as supabase } from "./supabase";

// Interface definition for a family member
export interface FamilyMember {
  id: string; // UUID generated by the database
  user_id: string; // UUID of the primary user who invited this member
  member_email: string; // Email of the invited family member
  member_name: string; // Name of the invited family member
  relationship: string; // Relationship to the primary user (e.g., "Hijo", "CÃ³nyuge")
  status: "pending" | "active" | "rejected"; // Invitation status
  permissions: { // Permissions granted to this member
    view_all: boolean; // Can view all documents?
    download: boolean; // Can download documents?
    edit: boolean; // Can edit document metadata?
    categories: string[]; // Specific categories the member can access (if view_all is false)
  };
  created_at: string; // Timestamp of creation
  updated_at: string; // Timestamp of last update
}

/**
 * Service object for managing family members and related sharing.
 * Assumes these methods are called from a context where supabaseBrowserClient is valid (client-side).
 */
export const familyService = {
  /**
   * Fetches all family members invited by the currently authenticated user.
   */
  async getFamilyMembers(): Promise<FamilyMember[]> {
    console.log("Fetching family members...");
    try {
      // Use the imported supabase client (originally supabaseBrowserClient)
      const { data: userData, error: userError } = await supabase.auth.getUser();

      if (userError || !userData?.user) {
        console.error("getFamilyMembers: User not authenticated.", userError);
        throw new Error("User not authenticated");
      }
      const userId = userData.user.id;

      const { data, error } = await supabase
        .from("family_members") // Ensure this table name is correct
        .select("*")
        .eq("user_id", userId) // Fetch members invited BY this user
        .order("created_at", { ascending: false });

      if (error) {
        console.error("Error fetching family members:", error);
        throw error;
      }

      console.log(`Fetched ${data?.length || 0} family members.`);
      return data || []; // Return fetched data or empty array

    } catch (error) {
      console.error("Error in getFamilyMembers:", error);
      throw error; // Re-throw the error for the caller
    }
  },

  /**
   * Invites a new family member by creating a record in the database.
   * In a real application, this would typically trigger an email invitation.
   * @param memberData - Information about the member to invite and their permissions.
   */
  async inviteFamilyMember(memberData: {
    member_email: string;
    member_name: string;
    relationship: string;
    permissions: FamilyMember['permissions']; // Use type from interface
  }): Promise<FamilyMember> {
    console.log(`Attempting to invite family member: ${memberData.member_email}`);
    try {
      const { data: userData, error: userError } = await supabase.auth.getUser();

      if (userError || !userData?.user) {
        console.error("inviteFamilyMember: User not authenticated.", userError);
        throw new Error("User not authenticated");
      }
      const userId = userData.user.id;

      // 1. Check if this user has already invited this email address
      const { data: existingMember, error: checkError } = await supabase
        .from("family_members")
        .select("id") // Only need to know if it exists
        .eq("user_id", userId)
        .eq("member_email", memberData.member_email)
        .limit(1) // Optimization: only need one record
        .maybeSingle(); // Returns null if not found, instead of error

      if (checkError) {
        console.error("Error checking for existing family member:", checkError);
        throw checkError;
      }

      if (existingMember) {
        console.warn(`Invitation already exists for ${memberData.member_email} by user ${userId}.`);
        throw new Error("This email address has already been invited.");
      }

      // 2. Insert the new family member invitation record
      console.log(`Inserting invitation for ${memberData.member_email}`);
      const { data: newMember, error: insertError } = await supabase
        .from("family_members")
        .insert({
          user_id: userId,
          member_email: memberData.member_email,
          member_name: memberData.member_name,
          relationship: memberData.relationship,
          status: "pending", // Initial status is pending
          permissions: memberData.permissions,
        })
        .select() // Select the newly inserted row
        .single(); // Expect only one row to be inserted

      if (insertError) {
        console.error("Error inserting family member invitation:", insertError);
        throw insertError;
      }

      console.log(`Successfully invited ${memberData.member_email}. ID: ${newMember.id}`);
      // TODO: Implement email sending logic here in a real application
      // await sendInvitationEmail(newMember.member_email, newMember.id, userData.user.email);

      return newMember;

    } catch (error) {
      console.error("Error during inviteFamilyMember:", error);
      // Check if it's the specific "already invited" error and re-throw
      if (error instanceof Error && error.message === "This email address has already been invited.") {
          throw error;
      }
      // Throw a more generic error otherwise
      throw new Error("Failed to invite family member.");
    }
  },

  /**
   * Updates an existing family member record (e.g., permissions, status).
   * @param id - The ID of the family member record to update.
   * @param updates - An object containing the fields to update.
   */
  async updateFamilyMember(id: string, updates: Partial<Omit<FamilyMember, 'id' | 'user_id' | 'created_at'>>): Promise<FamilyMember> {
     console.log(`Updating family member with ID: ${id}`);
     // Ensure sensitive fields like user_id are not accidentally updated
     const { user_id, created_at, id: memberId, ...safeUpdates } = updates as any;

    try {
        // RLS policies should ensure only the inviting user can update
        const { data: updatedMember, error } = await supabase
            .from("family_members")
            .update(safeUpdates)
            .eq("id", id)
            .select()
            .single();

        if (error) {
            console.error(`Error updating family member with id ${id}:`, error);
            throw error;
        }

        console.log(`Successfully updated family member ${id}.`);
        return updatedMember;

    } catch(error) {
        console.error("Error during updateFamilyMember:", error);
        throw new Error("Failed to update family member.");
    }
  },

  /**
   * Removes a family member invitation/record.
   * @param id - The ID of the family member record to delete.
   */
  async removeFamilyMember(id: string): Promise<void> {
     console.log(`Removing family member with ID: ${id}`);
    try {
        // RLS should ensure only the inviting user can delete
        const { error } = await supabase
            .from("family_members")
            .delete()
            .eq("id", id);

        if (error) {
            console.error(`Error removing family member with id ${id}:`, error);
            throw error;
        }
        console.log(`Successfully removed family member ${id}.`);
        // TODO: Consider cleanup - e.g., remove associated shared documents?

    } catch (error) {
         console.error("Error during removeFamilyMember:", error);
         throw new Error("Failed to remove family member.");
    }
  },

  // --- Document Sharing with Family ---

  /**
   * Fetches documents shared specifically with family members by the current user.
   * Assumes a join table 'family_shared_documents' exists.
   */
  async getSharedDocumentsWithFamily(): Promise<any[]> {
     console.log("Fetching documents shared with family...");
    try {
      const { data: userData, error: userError } = await supabase.auth.getUser();

      if (userError || !userData?.user) {
         console.error("getSharedDocumentsWithFamily: User not authenticated.", userError);
        throw new Error("User not authenticated");
      }
      const userId = userData.user.id;

      // Query the join table, joining with documents and family_members tables
      const { data, error } = await supabase
        .from("family_shared_documents") // Ensure this join table exists
        .select(`
          *,
          document:documents(*),
          member:family_members(*)
        `)
        .eq("user_id", userId) // Assuming user_id is the sharer's ID in the join table
        .order("created_at", { ascending: false });

      if (error) {
        console.error("Error fetching shared documents with family:", error);
        throw error;
      }

      console.log(`Fetched ${data?.length || 0} family share records.`);
      return data || [];

    } catch (error) {
        console.error("Error in getSharedDocumentsWithFamily:", error);
        throw error;
    }
  },

  /**
   * Shares a specific document with one or more family members.
   * Creates records in the 'family_shared_documents' join table.
   * @param documentId - The ID of the document to share.
   * @param memberIds - An array of family member record IDs to share with.
   */
  async shareDocumentWithFamily(documentId: string, memberIds: string[]): Promise<void> {
     console.log(`Sharing document ${documentId} with family members: ${memberIds.join(', ')}`);
     if (!memberIds || memberIds.length === 0) {
         console.warn("No family member IDs provided for sharing.");
         return;
     }

    try {
      const { data: userData, error: userError } = await supabase.auth.getUser();

      if (userError || !userData?.user) {
        console.error("shareDocumentWithFamily: User not authenticated.", userError);
        throw new Error("User not authenticated");
      }
      const userId = userData.user.id;

      // Prepare data for batch insert into the join table
      const insertData = memberIds.map((memberId) => ({
        user_id: userId, // The user doing the sharing
        document_id: documentId,
        family_member_id: memberId, // The family member receiving access
        // Add other relevant fields if needed, e.g., shared_at timestamp (defaults to now())
      }));

      // Perform batch insert
      const { error } = await supabase
        .from("family_shared_documents") // Ensure this table name is correct
        .insert(insertData);

      if (error) {
        console.error("Error inserting family share records:", error);
        // Handle specific errors, e.g., duplicate shares if constraints exist
        if (error.code === '23505') { // Unique constraint violation
            console.warn(`Attempted to share document ${documentId} which might already be shared with some members.`);
            // Decide if this should be a user-facing error or just logged
        }
        throw error;
      }

      console.log(`Successfully shared document ${documentId} with ${memberIds.length} family members.`);

    } catch (error) {
        console.error("Error during shareDocumentWithFamily:", error);
        throw new Error("Failed to share document with family members.");
    }
  },

  /**
   * Removes access to a specific shared document for a specific family member.
   * Deletes the corresponding record from the 'family_shared_documents' join table.
   * @param documentId - The ID of the document.
   * @param memberId - The ID of the family member record whose access should be revoked.
   */
  async removeSharedDocument(documentId: string, memberId: string): Promise<void> {
     console.log(`Removing access to document ${documentId} for family member ${memberId}`);
    try {
        // RLS on the join table should ensure only the owner can remove shares
        const { error } = await supabase
            .from("family_shared_documents")
            .delete()
            .eq("document_id", documentId)
            .eq("family_member_id", memberId);
            // Optionally add .eq("user_id", userId) if RLS isn't sufficient

        if (error) {
            console.error(`Error removing shared document access:`, error);
            throw error;
        }
        console.log(`Successfully removed access to document ${documentId} for member ${memberId}.`);

    } catch (error) {
         console.error("Error during removeSharedDocument:", error);
         throw new Error("Failed to remove shared document access.");
    }
  },
};
